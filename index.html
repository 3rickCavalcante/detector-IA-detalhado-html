<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Detector de IA - An√°lise Detalhada</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh; padding: 20px; 
        }
        .container { max-width: 1200px; margin: 0 auto; }
        .header { text-align: center; color: white; margin-bottom: 40px; }
        .header h1 { font-size: 2.5rem; margin-bottom: 10px; }
        .app-card { 
            background: white; border-radius: 15px; 
            box-shadow: 0 20px 40px rgba(0,0,0,0.1); padding: 40px; 
            margin-bottom: 20px;
        }
        .text-area { 
            width: 100%; min-height: 200px; padding: 20px; 
            border: 2px solid #e2e8f0; border-radius: 10px; 
            font-size: 1rem; resize: vertical; margin-bottom: 20px;
            font-family: monospace; line-height: 1.6;
        }
        .analyze-btn { 
            background: #2563eb; color: white; border: none; 
            padding: 15px 30px; border-radius: 10px; font-size: 1.1rem; 
            cursor: pointer; width: 100%; margin-bottom: 20px;
        }
        .analyze-btn:disabled { background: #94a3b8; cursor: not-allowed; }
        .result { margin-top: 20px; padding: 20px; background: #f8fafc; border-radius: 10px; }
        .stats { background: #e2e8f0; padding: 10px; border-radius: 5px; margin-bottom: 10px; }
        
        /* Estilos para termos suspeitos */
        .termo-suspeito {
            background-color: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 3px;
            padding: 2px 4px;
            margin: 0 1px;
            cursor: help;
            position: relative;
        }
        .termo-suspeito:hover {
            background-color: #fde68a;
            z-index: 1000;
        }
        .termo-suspeito[data-tipo="expressao_formal"] { border-color: #ef4444; background-color: #fef2f2; }
        .termo-suspeito[data-tipo="conectivo_complexo"] { border-color: #8b5cf6; background-color: #faf5ff; }
        .termo-suspeito[data-tipo="voz_passiva"] { border-color: #06b6d4; background-color: #ecfeff; }
        .termo-suspeito[data-tipo="superlativo"] { border-color: #f59e0b; background-color: #fffbeb; }
        
        .texto-destacado {
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            line-height: 1.8;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .relatorio-termos {
            margin-top: 20px;
        }
        
        .tipo-termo {
            background: #f8fafc;
            border-left: 4px solid #2563eb;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        
        .termo-item {
            background: white;
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            border-left: 3px solid #94a3b8;
        }
        
        .legenda {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
        }
        
        .legenda-item {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 5px 10px;
            background: #f8fafc;
            border-radius: 5px;
            font-size: 0.9em;
        }
        
        .legenda-cor {
            width: 15px;
            height: 15px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîç Detector de IA - An√°lise Detalhada</h1>
            <p>Identifique termos e express√µes suspeitos de terem sido gerados por IA</p>
        </div>
        
        <div class="app-card">
            <h3>üìù Cole seu texto para an√°lise</h3>
            <textarea class="text-area" id="textInput" placeholder="Cole o texto que deseja analisar aqui..."></textarea>
            
            <div class="stats" id="textStats">
                Caracteres: 0 | Palavras: 0 | Frases: 0
            </div>
            
            <button class="analyze-btn" onclick="analyzeText()" id="analyzeBtn">Analisar Texto</button>
            <div id="result"></div>
        </div>
    </div>
    
    <script>
        // Padr√µes lingu√≠sticos t√≠picos de IA
        const padroesIA = {
            'expressoes_formais': [
                '√© importante destacar', 'conv√©m ressaltar', 'considerando os fatores',
                'pode-se inferir', '√© fundamental observar', 'observa-se que',
                'conclui-se que', 'de maneira clara e objetiva', 'abordagem sistem√°tica',
                'o presente estudo', 'de acordo com', 'vale ressaltar', 'verifica-se que',
                'cabe salientar', '√© pertinente mencionar', 'pressup√µe-se que'
            ],
            'conectivos_complexos': [
                'portanto', 'consequentemente', 'adicionalmente', 'notavelmente',
                'consideravelmente', 'significativamente', 'efetivamente'
            ],
            'estruturas_passivas': [
                '√© realizado', '√© observado', '√© verificado', '√© constatado',
                '√© poss√≠vel identificar', 'pode ser observado', 'deve ser considerado'
            ],
            'palavras_superlativas': [
                'extremamente', 'altamente', 'profundamente', 'intensamente',
                'significativamente', 'consideravelmente', 'notavelmente'
            ]
        };

        // Fun√ß√£o para tokenizar texto
        function tokenizacaoSimples(texto) {
            const palavras = texto.match(/\b\w+\b/g);
            return palavras ? palavras.map(p => p.toLowerCase()) : [];
        }

        // Fun√ß√£o para dividir frases
        function dividirFrases(texto) {
            const frases = texto.split(/[.!?]+(?:\s+|$)/);
            return frases.filter(f => f.trim()).map(f => f.trim());
        }

        // Fun√ß√£o para analisar termos suspeitos
        function analisarTermosSuspeitos(texto) {
            const termosDetectados = [];
            const textoLower = texto.toLowerCase();
            
            // Analisar express√µes formais t√≠picas de IA
            padroesIA.expressoes_formais.forEach(expressao => {
                const regex = new RegExp(expressao, 'gi');
                let match;
                while ((match = regex.exec(textoLower)) !== null) {
                    const start = match.index;
                    const end = start + match[0].length;
                    const contexto = texto.substring(
                        Math.max(0, start - 50), 
                        Math.min(texto.length, end + 50)
                    );
                    
                    termosDetectados.push({
                        termo: texto.substring(start, end),
                        tipo: 'expressao_formal',
                        justificativa: 'Express√£o excessivamente formal comum em textos de IA',
                        contexto: contexto,
                        posicao: [start, end]
                    });
                }
            });
            
            // Analisar conectivos complexos
            padroesIA.conectivos_complexos.forEach(conectivo => {
                const regex = new RegExp('\\b' + conectivo + '\\b', 'gi');
                let match;
                while ((match = regex.exec(textoLower)) !== null) {
                    termosDetectados.push({
                        termo: texto.substring(match.index, match.index + match[0].length),
                        tipo: 'conectivo_complexo',
                        justificativa: 'Uso frequente de conectivos complexos t√≠pico de IA',
                        contexto: texto.substring(
                            Math.max(0, match.index - 30), 
                            Math.min(texto.length, match.index + match[0].length + 30)
                        ),
                        posicao: [match.index, match.index + match[0].length]
                    });
                }
            });
            
            // Analisar estruturas passivas
            padroesIA.estruturas_passivas.forEach(estrutura => {
                const regex = new RegExp(estrutura, 'gi');
                let match;
                while ((match = regex.exec(textoLower)) !== null) {
                    termosDetectados.push({
                        termo: texto.substring(match.index, match.index + match[0].length),
                        tipo: 'voz_passiva',
                        justificativa: 'Uso excessivo de voz passiva, comum em textos formais de IA',
                        contexto: texto.substring(
                            Math.max(0, match.index - 40), 
                            Math.min(texto.length, match.index + match[0].length + 40)
                        ),
                        posicao: [match.index, match.index + match[0].length]
                    });
                }
            });
            
            // Analisar palavras superlativas
            padroesIA.palavras_superlativas.forEach(superlativo => {
                const regex = new RegExp('\\b' + superlativo + '\\b', 'gi');
                let match;
                while ((match = regex.exec(textoLower)) !== null) {
                    termosDetectados.push({
                        termo: texto.substring(match.index, match.index + match[0].length),
                        tipo: 'superlativo',
                        justificativa: 'Uso frequente de intensificadores e superlativos',
                        contexto: texto.substring(
                            Math.max(0, match.index - 25), 
                            Math.min(texto.length, match.index + match[0].length + 25)
                        ),
                        posicao: [match.index, match.index + match[0].length]
                    });
                }
            });
            
            return termosDetectados;
        }

        // Fun√ß√£o para gerar texto destacado
        function gerarTextoDestacado(texto, termosDetectados) {
            if (!termosDetectados || termosDetectados.length === 0) {
                return texto;
            }
            
            let textoDestacado = texto;
            // Ordenar termos por posi√ß√£o (do final para o in√≠cio para evitar problemas com √≠ndices)
            const termosOrdenados = [...termosDetectados].sort((a, b) => b.posicao[0] - a.posicao[0]);
            
            termosOrdenados.forEach(termoInfo => {
                const [start, end] = termoInfo.posicao;
                const termoOriginal = texto.substring(start, end);
                
                // Criar span com destaque
                const spanDestacado = `<span class="termo-suspeito" data-tipo="${termoInfo.tipo}" title="${termoInfo.justificativa}">${termoOriginal}</span>`;
                
                // Inserir no texto
                textoDestacado = textoDestacado.substring(0, start) + spanDestacado + textoDestacado.substring(end);
            });
            
            return textoDestacado;
        }

        // Fun√ß√£o para extrair features do texto
        function extrairFeatures(texto) {
            let textoAnalise = texto;
            if (texto.length > 5000) {
                textoAnalise = texto.substring(0, 2000) + 
                              texto.substring(texto.length/2 - 500, texto.length/2 + 500) + 
                              texto.substring(texto.length - 2000);
            }
            
            const palavras = tokenizacaoSimples(textoAnalise);
            const frases = dividirFrases(textoAnalise);
            
            const features = {};
            features.comprimento = texto.length;
            features.num_palavras = palavras.length;
            features.num_frases = frases.length;
            
            if (palavras.length > 0) {
                features.comp_medio_palavra = palavras.reduce((sum, p) => sum + p.length, 0) / palavras.length;
                features.palavras_por_frase = frases.length > 0 ? palavras.length / frases.length : 0;
                features.diversidade_lexical = new Set(palavras).size / palavras.length;
            } else {
                features.comp_medio_palavra = 0;
                features.palavras_por_frase = 0;
                features.diversidade_lexical = 0;
            }
            
            features.palavras_longas = palavras.length > 0 ? 
                palavras.filter(p => p.length > 6).length / palavras.length : 0;
            features.formalidade = calcularFormalidade(textoAnalise);
            
            return features;
        }

        // Fun√ß√£o para calcular formalidade
        function calcularFormalidade(texto) {
            const palavrasFormais = ['portanto', 'consequentemente', 'adicionalmente', 'fundamental'];
            const palavrasInformais = ['tipo', 'assim', 'ok', 'bem', 'acho', 't√°'];
            
            const textoLower = texto.toLowerCase();
            let formal = 0;
            let informal = 0;
            
            palavrasFormais.forEach(p => {
                if (textoLower.includes(p)) formal++;
            });
            
            palavrasInformais.forEach(p => {
                if (textoLower.includes(p)) informal++;
            });
            
            const total = tokenizacaoSimples(texto).length;
            return total > 0 ? (formal - informal) / total : 0;
        }

        // Fun√ß√£o para detectar IA (vers√£o simplificada sem modelo ML)
        function detectarIA(texto) {
            if (!texto || texto.trim().length < 20) {
                return {
                    ai_probability: 0.5,
                    human_probability: 0.5,
                    confidence: 0.1,
                    termos_suspeitos: [],
                    texto_destacado: texto
                };
            }
            
            try {
                // An√°lise de termos suspeitos
                const termosSuspeitos = analisarTermosSuspeitos(texto);
                const textoDestacado = gerarTextoDestacado(texto, termosSuspeitos);
                
                // An√°lise tradicional
                const features = extrairFeatures(texto);
                
                // Heur√≠stica baseada em features
                let probIA = 0.3;
                if (features.formalidade > 0.1) {
                    probIA = 0.7;
                }
                
                // Ajustar baseado em termos suspeitos
                if (termosSuspeitos.length > 0) {
                    probIA = Math.min(0.95, probIA + (termosSuspeitos.length * 0.05));
                }
                
                const confianca = 0.6 + (Math.abs(probIA - 0.5) * 0.4);
                
                // Agrupar termos por tipo para relat√≥rio
                const termosPorTipo = {};
                termosSuspeitos.forEach(termo => {
                    if (!termosPorTipo[termo.tipo]) {
                        termosPorTipo[termo.tipo] = [];
                    }
                    termosPorTipo[termo.tipo].push(termo);
                });
                
                const resultado = {
                    ai_probability: Math.round(probIA * 1000) / 1000,
                    human_probability: Math.round((1 - probIA) * 1000) / 1000,
                    confidence: Math.round(confianca * 100) / 100,
                    text_analyzed_length: texto.length,
                    termos_suspeitos: termosSuspeitos,
                    texto_destacado: textoDestacado,
                    estatisticas_deteccao: {
                        total_termos: termosSuspeitos.length,
                        termos_por_tipo: Object.fromEntries(
                            Object.entries(termosPorTipo).map(([tipo, termos]) => [tipo, termos.length])
                        ),
                        densidade_termos: termosSuspeitos.length / texto.split(/\s+/).length
                    }
                };
                
                return resultado;
                
            } catch (e) {
                console.error("Erro na detec√ß√£o:", e);
                return {
                    ai_probability: 0.5,
                    human_probability: 0.5,
                    confidence: 0.1,
                    termos_suspeitos: [],
                    texto_destacado: texto
                };
            }
        }

        // Event listeners e fun√ß√µes de UI
        document.getElementById('textInput').addEventListener('input', function() {
            const text = this.value;
            const chars = text.length;
            const words = text.trim() ? text.trim().split(/\s+/).length : 0;
            const sentences = text.split(/[.!?]+/).length - 1;
            document.getElementById('textStats').innerHTML = 
                `Caracteres: ${chars} | Palavras: ${words} | Frases: ${sentences}`;
        });

        async function analyzeText() {
            const text = document.getElementById('textInput').value.trim();
            const resultDiv = document.getElementById('result');
            const button = document.getElementById('analyzeBtn');
            
            if (text.length < 20) {
                resultDiv.innerHTML = '<p style="color: red;">‚ö†Ô∏è Texto muito curto (m√≠nimo 20 caracteres)</p>';
                return;
            }
            
            button.disabled = true;
            button.textContent = 'Analisando...';
            resultDiv.innerHTML = '<p>‚è≥ Analisando texto e identificando padr√µes suspeitos...</p>';
            
            // Simular processamento ass√≠ncrono
            setTimeout(() => {
                try {
                    const result = detectarIA(text);
                    const aiProb = Math.round(result.ai_probability * 100);
                    const humanProb = Math.round(result.human_probability * 100);
                    const confidence = Math.round(result.confidence * 100);
                    
                    let color = '#64748b';
                    let veredito = 'Indeterminado';
                    if (aiProb > 70) {
                        color = '#ef4444';
                        veredito = 'Provavelmente IA';
                    } else if (humanProb > 70) {
                        color = '#10b981';
                        veredito = 'Provavelmente Humano';
                    }
                    
                    let relatorioHTML = gerarRelatorioDetalhado(result);
                    
                    resultDiv.innerHTML = `
                        <div style="text-align: center; margin-bottom: 20px;">
                            <h3 style="color: ${color}">${veredito}</h3>
                            <p>ü§ñ Probabilidade de IA: <strong style="font-size: 1.2em;">${aiProb}%</strong></p>
                            <p>üë§ Probabilidade Humana: <strong style="font-size: 1.2em;">${humanProb}%</strong></p>
                            <p>üìä Confian√ßa da an√°lise: ${confidence}%</p>
                        </div>
                        ${relatorioHTML}
                    `;
                } catch (error) {
                    resultDiv.innerHTML = '<p style="color: red;">‚ùå Erro na an√°lise. Tente novamente.</p>';
                } finally {
                    button.disabled = false;
                    button.textContent = 'Analisar Texto';
                }
            }, 1000);
        }
        
        function gerarRelatorioDetalhado(result) {
            const termos = result.termos_suspeitos || [];
            
            if (termos.length === 0) {
                return `
                    <div class="relatorio-termos">
                        <h4>‚úÖ Nenhum padr√£o suspeito detectado</h4>
                        <p>O texto n√£o apresenta os padr√µes t√≠picos de IA analisados.</p>
                    </div>
                `;
            }
            
            // Agrupar termos por tipo
            const termosPorTipo = {};
            termos.forEach(termo => {
                if (!termosPorTipo[termo.tipo]) {
                    termosPorTipo[termo.tipo] = [];
                }
                termosPorTipo[termo.tipo].push(termo);
            });
            
            // Gerar HTML para cada tipo
            let tiposHTML = '';
            for (const [tipo, termosTipo] of Object.entries(termosPorTipo)) {
                let termosHTML = termosTipo.map(termo => `
                    <div class="termo-item">
                        <strong>"${termo.termo}"</strong> - ${termo.justificativa}
                        <br><small>Contexto: "...${termo.contexto}..."</small>
                    </div>
                `).join('');
                
                const tipoLabel = {
                    'expressao_formal': 'Express√µes Formais',
                    'conectivo_complexo': 'Conectivos Complexos',
                    'voz_passiva': 'Voz Passiva',
                    'superlativo': 'Superlativos'
                }[tipo] || tipo;
                
                tiposHTML += `
                    <div class="tipo-termo">
                        <h5>${tipoLabel} (${termosTipo.length} ocorr√™ncias)</h5>
                        ${termosHTML}
                    </div>
                `;
            }
            
            return `
                <div class="relatorio-termos">
                    <h4>üîç Relat√≥rio de An√°lise Detalhada</h4>
                    <p><strong>${termos.length} termos/padr√µes suspeitos detectados</strong></p>
                    
                    <div class="legenda">
                        <div class="legenda-item">
                            <div class="legenda-cor" style="background-color: #fef2f2; border: 1px solid #ef4444;"></div>
                            <span>Express√µes Formais</span>
                        </div>
                        <div class="legenda-item">
                            <div class="legenda-cor" style="background-color: #faf5ff; border: 1px solid #8b5cf6;"></div>
                            <span>Conectivos Complexos</span>
                        </div>
                        <div class="legenda-item">
                            <div class="legenda-cor" style="background-color: #ecfeff; border: 1px solid #06b6d4;"></div>
                            <span>Voz Passiva</span>
                        </div>
                        <div class="legenda-item">
                            <div class="legenda-cor" style="background-color: #fffbeb; border: 1px solid #f59e0b;"></div>
                            <span>Superlativos</span>
                        </div>
                    </div>
                    
                    <div class="texto-destacado">
                        <h5>Texto com termos destacados:</h5>
                        <div>${result.texto_destacado}</div>
                    </div>
                    
                    <div style="margin-top: 20px;">
                        <h5>üìã Detalhamento dos padr√µes detectados:</h5>
                        ${tiposHTML}
                    </div>
                </div>
            `;
        }
        
        // Exemplo de texto para teste
        document.getElementById('textInput').value = `√â importante destacar que a implementa√ß√£o de estrat√©gias eficazes requer uma abordagem sistem√°tica e coordenada. Considerando os fatores mencionados anteriormente, pode-se inferir que a solu√ß√£o proposta apresenta viabilidade t√©cnica e operacional. Observa-se que os resultados obtidos s√£o extremamente significativos e demonstram claramente a efic√°cia da metodologia empregada.

Por outro lado, quando fui ao mercado hoje, o padeiro foi muito simp√°tico comigo. Ele me deu um caf√© e a gente conversou um pouco sobre o time de futebol. Achei bem legal isso, sabe?`;

        document.getElementById('textInput').dispatchEvent(new Event('input'));
    </script>
</body>
</html>
