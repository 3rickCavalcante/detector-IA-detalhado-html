<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Detector de IA - An√°lise Avan√ßada</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh; padding: 20px; 
        }
        .container { max-width: 1200px; margin: 0 auto; }
        .header { text-align: center; color: white; margin-bottom: 40px; }
        .header h1 { font-size: 2.5rem; margin-bottom: 10px; }
        .app-card { 
            background: white; border-radius: 15px; 
            box-shadow: 0 20px 40px rgba(0,0,0,0.1); padding: 40px; 
            margin-bottom: 20px;
        }
        .text-area { 
            width: 100%; min-height: 200px; padding: 20px; 
            border: 2px solid #e2e8f0; border-radius: 10px; 
            font-size: 1rem; resize: vertical; margin-bottom: 20px;
            font-family: monospace; line-height: 1.6;
        }
        .analyze-btn { 
            background: #2563eb; color: white; border: none; 
            padding: 15px 30px; border-radius: 10px; font-size: 1.1rem; 
            cursor: pointer; width: 100%; margin-bottom: 20px;
            transition: all 0.3s ease;
        }
        .analyze-btn:hover { background: #1d4ed8; transform: translateY(-2px); }
        .analyze-btn:disabled { background: #94a3b8; cursor: not-allowed; transform: none; }
        .result { margin-top: 20px; padding: 20px; background: #f8fafc; border-radius: 10px; }
        .stats { background: #e2e8f0; padding: 10px; border-radius: 5px; margin-bottom: 10px; }
        
        /* Estilos para termos suspeitos */
        .termo-suspeito {
            background-color: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 3px;
            padding: 2px 4px;
            margin: 0 1px;
            cursor: help;
            position: relative;
        }
        .termo-suspeito:hover {
            background-color: #fde68a;
            z-index: 1000;
        }
        .termo-suspeito[data-tipo="expressao_formal"] { border-color: #ef4444; background-color: #fef2f2; }
        .termo-suspeito[data-tipo="conectivo_complexo"] { border-color: #8b5cf6; background-color: #faf5ff; }
        .termo-suspeito[data-tipo="voz_passiva"] { border-color: #06b6d4; background-color: #ecfeff; }
        .termo-suspeito[data-tipo="superlativo"] { border-color: #f59e0b; background-color: #fffbeb; }
        .termo-suspeito[data-tipo="repeticao"] { border-color: #dc2626; background-color: #fef2f2; }
        .termo-suspeito[data-tipo="estrutura_complexa"] { border-color: #7c3aed; background-color: #f5f3ff; }
        
        .texto-destacado {
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            line-height: 1.8;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .relatorio-termos {
            margin-top: 20px;
        }
        
        .tipo-termo {
            background: #f8fafc;
            border-left: 4px solid #2563eb;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        
        .termo-item {
            background: white;
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            border-left: 3px solid #94a3b8;
        }
        
        .legenda {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
        }
        
        .legenda-item {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 5px 10px;
            background: #f8fafc;
            border-radius: 5px;
            font-size: 0.9em;
        }
        
        .legenda-cor {
            width: 15px;
            height: 15px;
            border-radius: 3px;
        }
        
        .progress-bar {
            height: 10px;
            background: #e2e8f0;
            border-radius: 5px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            border-radius: 5px;
            transition: width 0.5s ease;
        }
        
        .metricas {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .metrica-card {
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .metrica-valor {
            font-size: 1.5rem;
            font-weight: bold;
            margin: 5px 0;
        }
        
        .dica {
            background: #dbeafe;
            border-left: 4px solid #2563eb;
            padding: 10px 15px;
            margin: 10px 0;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîç Detector de IA - An√°lise Avan√ßada</h1>
            <p>Identifique termos e express√µes suspeitos de terem sido gerados por IA com maior precis√£o</p>
        </div>
        
        <div class="app-card">
            <h3>üìù Cole seu texto para an√°lise</h3>
            <textarea class="text-area" id="textInput" placeholder="Cole o texto que deseja analisar aqui..."></textarea>
            
            <div class="stats" id="textStats">
                Caracteres: 0 | Palavras: 0 | Frases: 0 | Par√°grafos: 0
            </div>
            
            <button class="analyze-btn" onclick="analyzeText()" id="analyzeBtn">Analisar Texto</button>
            <div id="result"></div>
        </div>
    </div>
    
    <script>
        // Padr√µes lingu√≠sticos t√≠picos de IA (expandidos)
        const padroesIA = {
            'expressoes_formais': [
                '√© importante destacar', 'conv√©m ressaltar', 'considerando os fatores',
                'pode-se inferir', '√© fundamental observar', 'observa-se que',
                'conclui-se que', 'de maneira clara e objetiva', 'abordagem sistem√°tica',
                'o presente estudo', 'de acordo com', 'vale ressaltar', 'verifica-se que',
                'cabe salientar', '√© pertinente mencionar', 'pressup√µe-se que',
                'constata-se que', 'infere-se que', 'depreende-se que', 'evidencia-se que',
                'recomenda-se que', 'sugere-se que', 'prop√µe-se que', 'argumenta-se que',
                'destaca-se que', 'salienta-se que', 'ressalta-se que', 'enfatiza-se que',
                'sob essa perspectiva', 'nesse contexto', 'nesse sentido', 'nesse cen√°rio',
                'nessa conjuntura', 'nessa √≥tica', 'nessa perspectiva'
            ],
            'conectivos_complexos': [
                'portanto', 'consequentemente', 'adicionalmente', 'notavelmente',
                'consideravelmente', 'significativamente', 'efetivamente',
                'sobretudo', 'principalmente', 'especialmente', 'particularmente',
                'igualmente', 'similarmente', 'analogamente', 'paralelamente',
                'reciprocamente', 'correlatamente', 'correspondentemente'
            ],
            'estruturas_passivas': [
                '√© realizado', '√© observado', '√© verificado', '√© constatado',
                '√© poss√≠vel identificar', 'pode ser observado', 'deve ser considerado',
                's√£o apresentados', 'foram analisados', 'ser√° discutido', 'pode ser verificado',
                'devem ser considerados', 'podem ser observados', 'poder√£o ser implementados'
            ],
            'palavras_superlativas': [
                'extremamente', 'altamente', 'profundamente', 'intensamente',
                'significativamente', 'consideravelmente', 'notavelmente',
                'expressivamente', 'substancialmente', 'exponencialmente',
                'excepcionalmente', 'extraordinariamente', 'surpreendentemente'
            ],
            'expressoes_impessoais': [
                'h√° que se considerar', 'cabe mencionar', 'conv√©m notar',
                'vale observar', 'importa destacar', 'cumpre ressaltar',
                'imp√µe-se considerar', 'recomenda-se atentar', 'sugere-se observar'
            ]
        };

        // Palavras e express√µes tipicamente humanas
        const padroesHumanos = [
            'tipo', 'assim', 'ok', 'bem', 'acho', 't√°', 'n√©', 'uai', 'oxente',
            'caramba', 'poxa', 'nossa', 'aff', 'puts', 'mano', 'cara', 'velho',
            'tipo assim', 'sei l√°', 'de repente', 'do nada', 'na moral',
            'fui l√°', 'da√≠', 'a√≠', 'ent√£o', 'sabe', 't√° ligado', 'c√™ acredita'
        ];

        // Fun√ß√£o para tokenizar texto
        function tokenizacaoSimples(texto) {
            const palavras = texto.match(/\b\w+\b/g);
            return palavras ? palavras.map(p => p.toLowerCase()) : [];
        }

        // Fun√ß√£o para dividir frases
        function dividirFrases(texto) {
            const frases = texto.split(/[.!?]+(?:\s+|$)/);
            return frases.filter(f => f.trim()).map(f => f.trim());
        }

        // Fun√ß√£o para dividir par√°grafos
        function dividirParagrafos(texto) {
            const paragrafos = texto.split(/\n\s*\n/);
            return paragrafos.filter(p => p.trim()).map(p => p.trim());
        }

        // Fun√ß√£o para analisar repeti√ß√µes
        function analisarRepeticoes(frases) {
            const repeticoes = [];
            const frasesSimplificadas = frases.map(f => 
                f.toLowerCase().replace(/[^\w\s]/g, '').replace(/\s+/g, ' ').trim()
            );
            
            for (let i = 0; i < frasesSimplificadas.length; i++) {
                for (let j = i + 1; j < frasesSimplificadas.length; j++) {
                    if (frasesSimplificadas[i] && frasesSimplificadas[j] &&
                        frasesSimplificadas[i] === frasesSimplificadas[j]) {
                        repeticoes.push({
                            frase: frases[i],
                            tipo: 'repeticao_exata',
                            justificativa: 'Frase repetida exatamente',
                            posicao: [i, j]
                        });
                    } else if (frasesSimplificadas[i] && frasesSimplificadas[j] &&
                             calcularSimilaridade(frasesSimplificadas[i], frasesSimplificadas[j]) > 0.8) {
                        repeticoes.push({
                            frase: frases[i],
                            tipo: 'repeticao',
                            justificativa: 'Frase muito similar detectada',
                            posicao: [i, j]
                        });
                    }
                }
            }
            
            return repeticoes;
        }

        // Fun√ß√£o para calcular similaridade entre strings
        function calcularSimilaridade(str1, str2) {
            const longer = str1.length > str2.length ? str1 : str2;
            const shorter = str1.length > str2.length ? str2 : str1;
            
            if (longer.length === 0) return 1.0;
            
            return (longer.length - calcularDistanciaEdicao(longer, shorter)) / parseFloat(longer.length);
        }

        // Fun√ß√£o para calcular dist√¢ncia de edi√ß√£o (Levenshtein)
        function calcularDistanciaEdicao(s1, s2) {
            s1 = s1.toLowerCase();
            s2 = s2.toLowerCase();
            
            const costs = [];
            for (let i = 0; i <= s1.length; i++) {
                let lastValue = i;
                for (let j = 0; j <= s2.length; j++) {
                    if (i === 0) {
                        costs[j] = j;
                    } else if (j > 0) {
                        let newValue = costs[j - 1];
                        if (s1.charAt(i - 1) !== s2.charAt(j - 1)) {
                            newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
                        }
                        costs[j - 1] = lastValue;
                        lastValue = newValue;
                    }
                }
                if (i > 0) costs[s2.length] = lastValue;
            }
            return costs[s2.length];
        }

        // Fun√ß√£o para analisar estrutura complexa
        function analisarEstruturaComplexa(frases) {
            const estruturasComplexas = [];
            
            frases.forEach((frase, index) => {
                // Verificar frases muito longas
                if (frase.split(/\s+/).length > 30) {
                    estruturasComplexas.push({
                        termo: frase.substring(0, 50) + '...',
                        tipo: 'estrutura_complexa',
                        justificativa: 'Frase excessivamente longa e complexa',
                        contexto: frase,
                        posicao: [index, index]
                    });
                }
                
                // Verificar m√∫ltiplas cl√°usulas
                const clausulas = frase.split(/[,;:]|\be\b|\bmas\b|\bpor√©m\b|\bcontudo\b/gi);
                if (clausulas.length >= 3) {
                    estruturasComplexas.push({
                        termo: frase.substring(0, 50) + '...',
                        tipo: 'estrutura_complexa',
                        justificativa: 'Frases com m√∫ltiplas cl√°usulas e subordina√ß√µes',
                        contexto: frase,
                        posicao: [index, index]
                    });
                }
            });
            
            return estruturasComplexas;
        }

        // Fun√ß√£o para analisar emo√ß√£o no texto
        function analisarEmocao(texto) {
            const palavrasPositivas = ['amo', 'adoro', 'incr√≠vel', 'maravilhoso', 'fant√°stico', 'excelente', 'perfeito'];
            const palavrasNegativas = ['odeio', 'detesto', 'horr√≠vel', 'terr√≠vel', 'p√©ssimo', 'ruim', 'chato'];
            const palavrasNeutras = ['considerando', 'observando', 'analisando', 'verificando', 'constatando'];
            
            const palavras = tokenizacaoSimples(texto);
            let emocaoScore = 0;
            
            palavras.forEach(palavra => {
                if (palavrasPositivas.includes(palavra)) emocaoScore += 2;
                if (palavrasNegativas.includes(palavra)) emocaoScore -= 2;
                if (palavrasNeutras.includes(palavra)) emocaoScore -= 1;
            });
            
            // Normalizar para escala 0-1
            return Math.max(0, (emocaoScore + 10) / 20);
        }

        // Fun√ß√£o para analisar termos suspeitos
        function analisarTermosSuspeitos(texto) {
            const termosDetectados = [];
            const textoLower = texto.toLowerCase();
            const frases = dividirFrases(texto);
            
            // Analisar express√µes formais t√≠picas de IA
            padroesIA.expressoes_formais.forEach(expressao => {
                const regex = new RegExp(expressao, 'gi');
                let match;
                while ((match = regex.exec(textoLower)) !== null) {
                    const start = match.index;
                    const end = start + match[0].length;
                    const contexto = texto.substring(
                        Math.max(0, start - 50), 
                        Math.min(texto.length, end + 50)
                    );
                    
                    termosDetectados.push({
                        termo: texto.substring(start, end),
                        tipo: 'expressao_formal',
                        justificativa: 'Express√£o excessivamente formal comum em textos de IA',
                        contexto: contexto,
                        posicao: [start, end],
                        peso: 1.5 // Peso maior para express√µes formais
                    });
                }
            });
            
            // Analisar conectivos complexos
            padroesIA.conectivos_complexos.forEach(conectivo => {
                const regex = new RegExp('\\b' + conectivo + '\\b', 'gi');
                let match;
                while ((match = regex.exec(textoLower)) !== null) {
                    termosDetectados.push({
                        termo: texto.substring(match.index, match.index + match[0].length),
                        tipo: 'conectivo_complexo',
                        justificativa: 'Uso frequente de conectivos complexos t√≠pico de IA',
                        contexto: texto.substring(
                            Math.max(0, match.index - 30), 
                            Math.min(texto.length, match.index + match[0].length + 30)
                        ),
                        posicao: [match.index, match.index + match[0].length],
                        peso: 1.2
                    });
                }
            });
            
            // Analisar estruturas passivas
            padroesIA.estruturas_passivas.forEach(estrutura => {
                const regex = new RegExp(estrutura, 'gi');
                let match;
                while ((match = regex.exec(textoLower)) !== null) {
                    termosDetectados.push({
                        termo: texto.substring(match.index, match.index + match[0].length),
                        tipo: 'voz_passiva',
                        justificativa: 'Uso excessivo de voz passiva, comum em textos formais de IA',
                        contexto: texto.substring(
                            Math.max(0, match.index - 40), 
                            Math.min(texto.length, match.index + match[0].length + 40)
                        ),
                        posicao: [match.index, match.index + match[0].length],
                        peso: 1.3
                    });
                }
            });
            
            // Analisar palavras superlativas
            padroesIA.palavras_superlativas.forEach(superlativo => {
                const regex = new RegExp('\\b' + superlativo + '\\b', 'gi');
                let match;
                while ((match = regex.exec(textoLower)) !== null) {
                    termosDetectados.push({
                        termo: texto.substring(match.index, match.index + match[0].length),
                        tipo: 'superlativo',
                        justificativa: 'Uso frequente de intensificadores e superlativos',
                        contexto: texto.substring(
                            Math.max(0, match.index - 25), 
                            Math.min(texto.length, match.index + match[0].length + 25)
                        ),
                        posicao: [match.index, match.index + match[0].length],
                        peso: 1.1
                    });
                }
            });
            
            // Analisar express√µes impessoais
            padroesIA.expressoes_impessoais.forEach(expressao => {
                const regex = new RegExp(expressao, 'gi');
                let match;
                while ((match = regex.exec(textoLower)) !== null) {
                    termosDetectados.push({
                        termo: texto.substring(match.index, match.index + match[0].length),
                        tipo: 'expressao_formal',
                        justificativa: 'Express√£o impessoal t√≠pica de linguagem formal/IA',
                        contexto: texto.substring(
                            Math.max(0, match.index - 40), 
                            Math.min(texto.length, match.index + match[0].length + 40)
                        ),
                        posicao: [match.index, match.index + match[0].length],
                        peso: 1.4
                    });
                }
            });
            
            // Analisar repeti√ß√µes
            const repeticoes = analisarRepeticoes(frases);
            repeticoes.forEach(rep => {
                termosDetectados.push({
                    termo: rep.frase.substring(0, 50) + (rep.frase.length > 50 ? '...' : ''),
                    tipo: 'repeticao',
                    justificativa: rep.justificativa,
                    contexto: `Repeti√ß√£o nas frases ${rep.posicao[0] + 1} e ${rep.posicao[1] + 1}`,
                    posicao: [0, 0], // Posi√ß√£o n√£o aplic√°vel para repeti√ß√µes
                    peso: 1.6 // Alto peso para repeti√ß√µes
                });
            });
            
            // Analisar estruturas complexas
            const estruturasComplexas = analisarEstruturaComplexa(frases);
            estruturasComplexas.forEach(est => {
                termosDetectados.push({
                    termo: est.termo,
                    tipo: 'estrutura_complexa',
                    justificativa: est.justificativa,
                    contexto: est.contexto,
                    posicao: est.posicao,
                    peso: 1.3
                });
            });
            
            return termosDetectados;
        }

        // Fun√ß√£o para gerar texto destacado
        function gerarTextoDestacado(texto, termosDetectados) {
            if (!termosDetectados || termosDetectados.length === 0) {
                return texto;
            }
            
            let textoDestacado = texto;
            // Ordenar termos por posi√ß√£o (do final para o in√≠cio para evitar problemas com √≠ndices)
            const termosOrdenados = [...termosDetectados]
                .filter(termo => termo.posicao[0] !== 0) // Filtrar repeti√ß√µes sem posi√ß√£o espec√≠fica
                .sort((a, b) => b.posicao[0] - a.posicao[0]);
            
            termosOrdenados.forEach(termoInfo => {
                const [start, end] = termoInfo.posicao;
                const termoOriginal = texto.substring(start, end);
                
                // Criar span com destaque
                const spanDestacado = `<span class="termo-suspeito" data-tipo="${termoInfo.tipo}" title="${termoInfo.justificativa}">${termoOriginal}</span>`;
                
                // Inserir no texto
                textoDestacado = textoDestacado.substring(0, start) + spanDestacado + textoDestacado.substring(end);
            });
            
            return textoDestacado;
        }

        // Fun√ß√£o para extrair features do texto
        function extrairFeatures(texto) {
            let textoAnalise = texto;
            if (texto.length > 5000) {
                textoAnalise = texto.substring(0, 2000) + 
                              texto.substring(texto.length/2 - 500, texto.length/2 + 500) + 
                              texto.substring(texto.length - 2000);
            }
            
            const palavras = tokenizacaoSimples(textoAnalise);
            const frases = dividirFrases(textoAnalise);
            const paragrafos = dividirParagrafos(texto);
            
            const features = {};
            features.comprimento = texto.length;
            features.num_palavras = palavras.length;
            features.num_frases = frases.length;
            features.num_paragrafos = paragrafos.length;
            
            if (palavras.length > 0) {
                features.comp_medio_palavra = palavras.reduce((sum, p) => sum + p.length, 0) / palavras.length;
                features.palavras_por_frase = frases.length > 0 ? palavras.length / frases.length : 0;
                features.palavras_por_paragrafo = paragrafos.length > 0 ? palavras.length / paragrafos.length : 0;
                features.diversidade_lexical = new Set(palavras).size / palavras.length;
            } else {
                features.comp_medio_palavra = 0;
                features.palavras_por_frase = 0;
                features.palavras_por_paragrafo = 0;
                features.diversidade_lexical = 0;
            }
            
            features.palavras_longas = palavras.length > 0 ? 
                palavras.filter(p => p.length > 6).length / palavras.length : 0;
            features.formalidade = calcularFormalidade(textoAnalise);
            features.emocao = analisarEmocao(textoAnalise);
            features.coesao = calcularCoesao(paragrafos);
            
            return features;
        }

        // Fun√ß√£o para calcular coes√£o entre par√°grafos
        function calcularCoesao(paragrafos) {
            if (paragrafos.length <= 1) return 1;
            
            let similaridadeTotal = 0;
            let pares = 0;
            
            for (let i = 0; i < paragrafos.length - 1; i++) {
                for (let j = i + 1; j < Math.min(i + 3, paragrafos.length); j++) {
                    const sim = calcularSimilaridade(
                        paragrafos[i].substring(0, 100),
                        paragrafos[j].substring(0, 100)
                    );
                    similaridadeTotal += sim;
                    pares++;
                }
            }
            
            return pares > 0 ? similaridadeTotal / pares : 1;
        }

        // Fun√ß√£o para calcular formalidade
        function calcularFormalidade(texto) {
            const palavrasFormais = ['portanto', 'consequentemente', 'adicionalmente', 'fundamental'];
            const palavrasInformais = ['tipo', 'assim', 'ok', 'bem', 'acho', 't√°'];
            
            const textoLower = texto.toLowerCase();
            let formal = 0;
            let informal = 0;
            
            palavrasFormais.forEach(p => {
                const matches = textoLower.match(new RegExp('\\b' + p + '\\b', 'g'));
                if (matches) formal += matches.length;
            });
            
            palavrasInformais.forEach(p => {
                const matches = textoLower.match(new RegExp('\\b' + p + '\\b', 'g'));
                if (matches) informal += matches.length;
            });
            
            const total = tokenizacaoSimples(texto).length;
            return total > 0 ? (formal - informal) / total : 0;
        }

        // Fun√ß√£o para detectar IA (vers√£o melhorada)
        function detectarIA(texto) {
            if (!texto || texto.trim().length < 20) {
                return {
                    ai_probability: 0.5,
                    human_probability: 0.5,
                    confidence: 0.1,
                    termos_suspeitos: [],
                    texto_destacado: texto,
                    metricas: {}
                };
            }
            
            try {
                // An√°lise de termos suspeitos
                const termosSuspeitos = analisarTermosSuspeitos(texto);
                const textoDestacado = gerarTextoDestacado(texto, termosSuspeitos);
                
                // An√°lise tradicional
                const features = extrairFeatures(texto);
                
                // C√°lculo de probabilidade baseado em m√∫ltiplos fatores
                let probIA = 0.3; // Base
                
                // Ajustar baseado em formalidade
                if (features.formalidade > 0.05) {
                    probIA += features.formalidade * 0.4;
                }
                
                // Ajustar baseado em termos suspeitos (com pesos)
                if (termosSuspeitos.length > 0) {
                    const pesoTotal = termosSuspeitos.reduce((sum, termo) => sum + (termo.peso || 1), 0);
                    const pesoMedio = pesoTotal / termosSuspeitos.length;
                    probIA = Math.min(0.95, probIA + (termosSuspeitos.length * pesoMedio * 0.03));
                }
                
                // Ajustar baseado em diversidade lexical (IA tende a ter menor diversidade)
                if (features.diversidade_lexical < 0.5) {
                    probIA += (0.5 - features.diversidade_lexical) * 0.3;
                }
                
                // Ajustar baseado em emo√ß√£o (IA tende a ser mais neutra)
                if (features.emocao < 0.3) {
                    probIA += (0.3 - features.emocao) * 0.2;
                }
                
                // Ajustar baseado em estrutura (frases muito longas)
                if (features.palavras_por_frase > 20) {
                    probIA += Math.min(0.2, (features.palavras_por_frase - 20) * 0.02);
                }
                
                // Limitar entre 0.05 e 0.95
                probIA = Math.max(0.05, Math.min(0.95, probIA));
                
                // Calcular confian√ßa baseada em m√∫ltiplos fatores
                let confianca = 0.5;
                confianca += Math.abs(probIA - 0.5) * 0.5; // Mais confiante quando pr√≥ximo dos extremos
                confianca += Math.min(0.2, termosSuspeitos.length * 0.05); // Mais termos = mais confian√ßa
                confianca += Math.min(0.1, features.num_palavras / 1000); // Textos maiores = mais confian√ßa
                
                confianca = Math.max(0.3, Math.min(0.95, confianca));
                
                // Agrupar termos por tipo para relat√≥rio
                const termosPorTipo = {};
                termosSuspeitos.forEach(termo => {
                    if (!termosPorTipo[termo.tipo]) {
                        termosPorTipo[termo.tipo] = [];
                    }
                    termosPorTipo[termo.tipo].push(termo);
                });
                
                const resultado = {
                    ai_probability: Math.round(probIA * 1000) / 1000,
                    human_probability: Math.round((1 - probIA) * 1000) / 1000,
                    confidence: Math.round(confianca * 100) / 100,
                    text_analyzed_length: texto.length,
                    termos_suspeitos: termosSuspeitos,
                    texto_destacado: textoDestacado,
                    metricas: features,
                    estatisticas_deteccao: {
                        total_termos: termosSuspeitos.length,
                        termos_por_tipo: Object.fromEntries(
                            Object.entries(termosPorTipo).map(([tipo, termos]) => [tipo, termos.length])
                        ),
                        densidade_termos: termosSuspeitos.length / texto.split(/\s+/).length,
                        peso_total: termosSuspeitos.reduce((sum, termo) => sum + (termo.peso || 1), 0)
                    }
                };
                
                return resultado;
                
            } catch (e) {
                console.error("Erro na detec√ß√£o:", e);
                return {
                    ai_probability: 0.5,
                    human_probability: 0.5,
                    confidence: 0.1,
                    termos_suspeitos: [],
                    texto_destacado: texto,
                    metricas: {}
                };
            }
        }

        // Event listeners e fun√ß√µes de UI
        document.getElementById('textInput').addEventListener('input', function() {
            const text = this.value;
            const chars = text.length;
            const words = text.trim() ? text.trim().split(/\s+/).length : 0;
            const sentences = text.split(/[.!?]+/).length - 1;
            const paragraphs = text.split(/\n\s*\n/).filter(p => p.trim()).length;
            document.getElementById('textStats').innerHTML = 
                `Caracteres: ${chars} | Palavras: ${words} | Frases: ${sentences} | Par√°grafos: ${paragraphs}`;
        });

        async function analyzeText() {
            const text = document.getElementById('textInput').value.trim();
            const resultDiv = document.getElementById('result');
            const button = document.getElementById('analyzeBtn');
            
            if (text.length < 20) {
                resultDiv.innerHTML = '<p style="color: red;">‚ö†Ô∏è Texto muito curto (m√≠nimo 20 caracteres)</p>';
                return;
            }
            
            button.disabled = true;
            button.textContent = 'Analisando...';
            resultDiv.innerHTML = '<p>‚è≥ Analisando texto e identificando padr√µes suspeitos...</p>';
            
            // Simular processamento ass√≠ncrono
            setTimeout(() => {
                try {
                    const result = detectarIA(text);
                    const aiProb = Math.round(result.ai_probability * 100);
                    const humanProb = Math.round(result.human_probability * 100);
                    const confidence = Math.round(result.confidence * 100);
                    
                    let color = '#64748b';
                    let veredito = 'Indeterminado';
                    if (aiProb > 70) {
                        color = '#ef4444';
                        veredito = 'Provavelmente IA';
                    } else if (humanProb > 70) {
                        color = '#10b981';
                        veredito = 'Provavelmente Humano';
                    }
                    
                    let relatorioHTML = gerarRelatorioDetalhado(result);
                    
                    resultDiv.innerHTML = `
                        <div style="text-align: center; margin-bottom: 20px;">
                            <h3 style="color: ${color}">${veredito
